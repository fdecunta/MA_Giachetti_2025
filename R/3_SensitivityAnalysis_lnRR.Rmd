---
title: "3 - Sensitivity analysis with lnRR"
author: "Giachetti et al."
date: "2025-02-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(metafor)
library(orchaRd)
library(patchwork)
library(rotl)
library(smatr)
library(tidyverse)
```

# Load data and cleaning

```{r}
raw_data <- read_csv("../data/Giachetti_2025_raw.csv", show_col_types = FALSE) %>% 
  janitor::clean_names()
```

```{r}
# Round all numeric variables to the fourth decimal
raw_data <- raw_data %>%
  mutate(across(where(is.numeric), ~ round(.x, 4)))

glimpse(raw_data)
```

```{r}
print("Rows removed: ")
raw_data %>% 
  filter(nurse_species == "unknown" | nurse_species == "various") %>% 
  nrow()

# Only 7 observations were removed

raw_data <- raw_data %>%  
  filter(nurse_species != "unknown", nurse_species != "various")
```

```{r}
# Create and effect size ID
raw_data <- raw_data %>% 
  mutate(id_es = row_number())
```

# Calculate effect sizes

First, remove cases that present their results with RII

```{r}
raw_data <- raw_data %>% 
  filter(unidad != "RII") %>% 
  select(-rii, -sd_rii, -n_rii)
```

## Log transformed ratio of means (lnRR)

Calculate lnRR using metafor package.

```{r}
raw_data <- escalc(measure = "ROM",
       m1i = mean_island,
       sd1i = sd_island,
       n1i = n_island,
       m2i = mean_bs,
       sd2i = sd_bs,
       n2i = n_bs,
       data = raw_data,
       var.names = c("lnRR", "lnRRV"))
```

Some cases where NAs because they have some mean == 0, and the means ratios can't be computed.

Calculate lnRR for the effect of nurse plant on soil nitrogen

```{r}
raw_data <- escalc(measure = "ROM",
       m1i = mean_island_nit,
       sd1i = sd_island_nit,
       n1i = n_island_fi,
       m2i = mean_bs_nit,
       sd2i = sd_bs_nit,
       n2i = n_bs_fi,
       data = raw_data,
       var.names = c("nit.lnRR", "nit.lnRRV"))
```

Calculate lnRR for the effect of nurse plant on soil phosphorus

```{r}
raw_data <- escalc(measure = "ROM",
       m1i = mean_island_p,
       sd1i = sd_island_p,
       n1i = n_island_fi,
       m2i = mean_bs_p,
       sd2i = sd_bs_p,
       n2i = n_bs_fi,
       data = raw_data,
       var.names = c("p.lnRR", "p.lnRRV"))
```

## Append information from databases

We need to add information about soil nitrogen and soil phosphorus

```{r}
processed_data <- read_csv("../data/Giachetti_2025_processed.csv", show_col_types = FALSE) %>% 
  select(id_es,
         soil_n,
         soil_phosphorus)
```

```{r}
alt_data <- raw_data %>% 
  left_join(processed_data, by = "id_es")
```


# Fertile island effect: Nitrogen

```{r}
alt_data_nitMean <- alt_data %>% 
  filter(!is.na(nit.lnRR), !is.na(nit.lnRRV))
```

## Facilitation and fertile island effect on N

### Meta analytic model using lnRR

```{r}
alt_data_nit <- alt_data %>% 
  filter(!is.na(lnRR), !is.na(lnRRV), !is.na(nit.lnRR), !is.na(nit.lnRRV))
```

#### Phylogenetic relationships

```{r}
taxa <- tnrs_match_names(names = unique(alt_data_nit$nurse_species),
                         context_name = "Land plants")
knitr::kable(taxa)
```

All the names matched. Now get tree:

```{r warning=FALSE}
## Get the tree using the Open Tree Taxonomy (OTT) IDs
tree <- tol_induced_subtree(taxa$ott_id)

## Remove IDs and get the species names
tree$tip.label <- strip_ott_ids(tree$tip.label, remove_underscores = TRUE)
```

Finally, compute the branch lengths and use them for the variance-covariance matrix. Also, create a "phylo" column with the species names that will be linked to the phylogenetic matrix.

```{r}
tree2 <- ape::compute.brlen(tree)
phylo_matrix <- ape::vcv(tree2, cor = TRUE)

alt_data_nit$phylo <- alt_data_nit$nurse_species
```

#### Variance‐covariance matrix for non-independence

```{r}
VCV <- vcalc(vi = lnRRV, 
             cluster = id_paper,  
             obs = id_es, 
             data = alt_data_nit,
             rho = 0.5)
```

#### Model selection

```{r}
mod.null <- rma.mv(yi = lnRR,
                  V = VCV,
                  method = "ML",
                  data = alt_data_nit,
                  test = "t",
                  mods = ~ nit.lnRR)

mod.1 <- rma.mv(yi = lnRR,
                  V = VCV,
                  random = list(~ 1 | id_es,
                                ~ 1 | id_paper),
                  method = "ML",
                  data = alt_data_nit,
                  test = "t",
                  mods = ~ nit.lnRR)
                

mod.2 <- rma.mv(yi = lnRR,
                  V = VCV,
                  random = list(~ 1 | id_es,
                                ~ 1 | id_paper,
                                ~ 1 | nurse_species),
                  method = "ML",
                  data = alt_data_nit,
                  test = "t",
                  mods = ~ nit.lnRR)

mod.3 <- rma.mv(yi = lnRR,
                  V = VCV,
                  random = list(~ 1 | id_es,
                                ~ 1 | id_paper,
                                ~ 1 | nurse_species,
                                ~ 1 | phylo),
                  method = "ML",
                  R = list(phylo = phylo_matrix),
                  data = alt_data_nit,
                  test = "t",
                  mods = ~ nit.lnRR)

```

```{r}
knitr::kable(AIC(mod.null, mod.1, mod.2, mod.3))
```


#### Best model

The best one was the model 1. Now rerun the model using Restricted Maximum Likelihood (REML) and test the significance of the moderator.

```{r}
mod.nitlnRR <- rma.mv(yi = lnRR,
                  V = VCV,
                  random = list(~ 1 | id_es,
                                ~ 1 | id_paper),
                  method = "REML",
                  data = alt_data_nit,
                  test = "t",
                  mods = ~ nit.lnRR)
```

```{r}
robust(mod.nitlnRR, cluster = alt_data_nit$id_paper)
```

## Facilitation and soil nitrogen (SoilGrid)

```{r}
mod.soilN <- rma.mv(yi = lnRR,
                    V = VCV,
                    random = list(~ 1 | id_es,
                                  ~ 1 | id_paper),
                    method = "REML",
                    data = alt_data_nit,
                    test = "t",
                    mods = ~ soil_n)
```

```{r}
robust(mod.soilN, cluster = alt_data_nit$id_paper)
```

## Facilitation and fertile island on P

### Meta analytic model using lnRR

```{r}
alt_data_p <- alt_data %>% 
  filter(!is.na(lnRR), !is.na(lnRRV), !is.na(p.lnRR), !is.na(p.lnRRV))
```

#### Phylogenetic relationships

```{r}
taxa <- tnrs_match_names(names = unique(alt_data_p$nurse_species),
                         context_name = "Land plants")
knitr::kable(taxa)
```

All the names matched. Now get tree:

```{r warning=FALSE}
## Get the tree using the Open Tree Taxonomy (OTT) IDs
tree <- tol_induced_subtree(taxa$ott_id)

## Remove IDs and get the species names
tree$tip.label <- strip_ott_ids(tree$tip.label, remove_underscores = TRUE)
```

Finally, compute the branch lengths and use them for the variance-covariance matrix. Also, create a "phylo" column with the species names that will be linked to the phylogenetic matrix.

```{r}
tree2 <- ape::compute.brlen(tree)
phylo_matrix <- ape::vcv(tree2, cor = TRUE)

alt_data_p$phylo <- alt_data_p$nurse_species
```

#### Variance‐covariance matrix for non-independence

```{r}
VCV <- vcalc(vi = lnRRV, 
             cluster = id_paper,  
             obs = id_es, 
             data = alt_data_p,
             rho = 0.5)
```

#### Model selection

```{r}
mod.null <- rma.mv(yi = lnRR,
                  V = VCV,
                  method = "ML",
                  data = alt_data_p,
                  test = "t",
                  mods = ~ p.lnRR)

mod.1 <- rma.mv(yi = lnRR,
                  V = VCV,
                  random = list(~ 1 | id_es,
                                ~ 1 | id_paper),
                  method = "ML",
                  data = alt_data_p,
                  test = "t",
                  mods = ~ p.lnRR)
                

mod.2 <- rma.mv(yi = lnRR,
                  V = VCV,
                  random = list(~ 1 | id_es,
                                ~ 1 | id_paper,
                                ~ 1 | nurse_species),
                  method = "ML",
                  data = alt_data_p,
                  test = "t",
                  mods = ~ p.lnRR)

mod.3 <- rma.mv(yi = lnRR,
                  V = VCV,
                  random = list(~ 1 | id_es,
                                ~ 1 | id_paper,
                                ~ 1 | nurse_species,
                                ~ 1 | phylo),
                  method = "ML",
                  R = list(phylo = phylo_matrix),
                  data = alt_data_p,
                  test = "t",
                  mods = ~ p.lnRR)

```

```{r}
knitr::kable(AIC(mod.null, mod.1, mod.2, mod.3))
```


#### Best model

The best one was the model 1. Now rerun the model using Restricted Maximum Likelihood (REML) and test the significance of the moderator.

```{r}
mod.plnRR <- rma.mv(yi = lnRR,
                  V = VCV,
                  random = list(~ 1 | id_es,
                                ~ 1 | id_paper),
                  method = "REML",
                  data = alt_data_p,
                  test = "t",
                  mods = ~ p.lnRR)
```

```{r}
robust(mod.plnRR, cluster = alt_data_p$id_paper)
```

## Facilitation and soil phosphorus (SoilGrid)

```{r}
mod.soilP <- rma.mv(yi = lnRR,
                    V = VCV,
                    random = list(~ 1 | id_es,
                                  ~ 1 | id_paper),
                    method = "REML",
                    data = alt_data_p,
                    test = "t",
                    mods = ~ soil_phosphorus)
```

```{r}
robust(mod.soilP, cluster = alt_data_p$id_paper)
```
